
\chapter{The Rust programming language}

\chapter*{Introduction}

Rust is an open-source, general purpose, multi paradigm, compiled, statically and strongly typed language maintained by Rust Foundation.

Although general purpose, language lends itself particularly well to systems programming, where software reliability, scalability and efficiency are paramount.
These qualities can be largely attributed to powerful and expressive type system and ownership based memory management system which guarantees memory safety without a garbage collector.

\section{Data types}

% TODO: Scalars, Boolean, character, tuples, array, slice, str

\subsection{User defined types}

Rust provides 3 ways to construct used defined aggregate types which.
These are:
- \texttt{struct}s
- \texttt{enum}s
- \texttt{union}s

We focus on the first two of these.

\paragraph{\texttt{struct}s}

Struct is a heterogeneous product of other types, they are analogous to struct types in C, the record types of the ML family, or the struct types of the Lisp family. 
They constitute the basic building blocks for any user defined types.

A struct type is a heterogeneous product of other types, called the fields of the type. 

The memory layout of a struct is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the repr attribute. In either case, fields may be given in any order in a corresponding struct expression; the resulting struct value will always have the same memory layout.

The fields of a struct may be qualified by visibility modifiers, to allow access to data in a struct outside a module.

A tuple struct type is just like a struct type, except that the fields are anonymous.

A unit-like struct type is like a struct type, except that it has no fields. The one value constructed by the associated struct expression is the only value that inhabits such a type.

\section{Implementations}

Functionality of a type is not provided inline with it's definition like in most C like languages. 
Instead it's associated with a type by so called \textit{implementations}.
Implementations for a type are contained within a block introduced by the \texttt{impl} keyword.

There are two types of implementations:
- inherent implementations
- trait implementations

All items within impl block are called associated items

Functions defined within impl blocks are called associated functions and can be accessed with qualification \texttt{<type-name>::<function-name>}.

Within an implementation both \texttt{self} and \texttt{Self} keywords can be used.
\texttt{self} can be used in associated function definitions within an impl block as first parameter. 
Such functions are called methods and the \texttt{self} parameter denotes the receiver of method call. 
\texttt{self} can be additionally qualified with immutable or mutable reference \texttt{\&} or \texttt{\&mut}.

\texttt{Self} is a type alias that refers to implementing type.

%TODO: add an example for each 

\subsection{Inherent implementations}

We will shorthand implementation to impl which is common in Rust terminology.

%FIXME: is nominal the right word here? Maybe just use named instead?
Inherent impls associate contents of an \texttt{impl} block with specified nominal type.
Such blocks can contain definition of a constants or functions. 

\section{Generic types}

As of version 1.80 Rust provides 3 kinds of generic parameters types can use. 
These are:
- type parameters
- constant parameters
- lifetime parameters
Type which uses any generic parameters is said to be generic.

\subsection{Type parameters}

Type parameters can be used in function or type definition; they represent an abstract type which must be specified (or inferred) during compilation.
Type generics are most commonly used for collections since they can contain arbitrary object and don't need to know almost anything about the inner types.

However, one can't do much with truly arbitrary type, even collections require ordering for tree structures, hashing for hash based collections and even the simplest collections
like vectors and queues need to know that types they contain have finite size, or can be shared across thread boundaries. Most languages either provide these kinds of behavior
inductively by the structure of a type but that's not what Rust does. Rust requires that pretty much all capabilities of a type are specified.

Capabilities of a type parameter are expressed using traits which we in the next section.

\subsection{Constant parameters}

Similarity to how types can be generic over type, rust allows types to be generic by a constant value. These, so called, dependent types
provide brand new level of expressive power, statically sized arrays especially become much more useful. This makes stack based allocations much more common,
improving performance and reducing heap fragmentation, but for our purposes it allows type system verify and enforce certain quantities or reason about them in an abstract 
way which, as we will show in this study, can be used to express very complex systems.

\subsection{Lifetime parameters}

Lifetime parameters are standout feature of Rust. They represent duration based on lexical scoping for how long reference remains valid, so being generic over lifetime means being generic
to how long given reference can be held.

\section{Traits}

Traits provide an ability to express shared behavior in abstract way \cite{rustbook}. We are mostly interested in their use in \textit{trait bounds} on types and type parameters.
Trait bounds declare contracts that types must fulfil or else the program will be rejected. 
We used it to enforce use of valid data formats and proper sequencing of operations.

As mentioned in the previous section, type parameters don't have any capabilities unless explicitly declared. Trait bounds serve that exact purpose.
Types and generic parameters have their requirements states in such where clause and these requirements are checked at call site.

What distinguishes Rust's traits from most other languages is its unique scheme of implementing functionality for types.
Trait for a type is implemented in a very similar fashion to inherent impls using \texttt{impl Trait for Type \{ ... \}} syntax.

Such impl block must contain definition for all items a trait provides.
Traits can uniquely, be implemented generically for all types that salify bounds using an \textbf{blanket impl} \texttt{impl<T> Trait for T where T: ... \{ ... \}}.
This will even influence types from crate external to trait's definition. Blanket impls however come with significant downside - a blanket impl is the only impl for that trait that may exist.
This requirement is overly conservative and stems from necessity to guarantee impl coherence which we discuss in the next section

\section{Implementation Coherence}

Rust must be always able to uniquely determine which method corresponds to which impl block that is, impl blocks must be coherent with each other, they must not interfere or overlap.
That's the reason why as of 2024 Rust enforces one blanket impl - it cannot guarantee that two blanket impls of the same trait don't target some type twice.
However, if inherent or trait impl's target a specific generic type with at least one type parameter differing between the two impls coherence is preserved and program passes orphan rule.   


\subsection{Orphan Rule}