\chapter{OpenGL wrapper library}

In this chapter, we demonstrate how Rust's type system can be harnessed to create a safe wrapper library for modern OpenGL, specifically targeting version 4.6. Our goal is to cover the most essential components of the OpenGL specification and staying as close to the original spec as possible. 
In many cases, we implement a minimal subset of functionality to demonstrate that, once a specific feature is in place, it can be readily extended to encompass a broader scope of the API.

Besides the wrapper library the purpose of this study was to identify common patterns that arise during type driven design.

\section*{Overview}

The resulting library was named \textit{GPU bulwark} since it provides strong foundations for safer programming on the GPU, and could easily be extended to other GPU programming APIs.

Library at its root is logically divided into two halves: (1) main OpenGL wrapper and (2) general-purpose auxiliary modules which contain implementations of various patterns we have recognized.
%
\section{External dependencies}
%
Our library utilizes several publicly available crates from crates.io, we will briefly discuss their purposes below:
\begin{itemize}
    \item \texttt{gl} - generates raw OpenGL bindings for Rust using build script. Additionally, it exposes a single function that loads function pointers using the provided routine. 
    These bindings use C types and need to be invoked in \texttt{unsafe} context.
    \item \texttt{derive\_move} - is a procedural macro crate that expands \texttt{derive} to support more built-in traits. It significantly reduces code boilerplate.
    \item \texttt{concat\_idents} - provides singular procedural macro that allows to concatenate identifiers akin to C's \texttt{\#\#} operator. We utilize this macro for identifier generation for certain OpenGL names that strictly follow a naming convection. This yet again helps to reduce boilerplate, makes code more succinct and minimizes risk of typos.
    \item \texttt{nalgebra} and \texttt{nalgebra-glm} define algorithms and types for linear algebra computations. They are not used directly in our library for their functionality but rather for optional integration with \texttt{gpu-bulwark}.
\end{itemize}
% FIXME: replace this 
Remaining packages are imported for use in examples only.
%
\begin{itemize}
    \item \texttt{thiserror} and \texttt{anyhow} - very popular crates that make error handling more ergonomic.
    \item \texttt{raw-window-handle}, \texttt{glutin} and \texttt{winit} allow for cross platform window creation and OpenGL context initialization.
\end{itemize}

\section{Auxiliary modules and crates}

All general purpose design patterns we encountered during development are implemented in these modules.
% FIXME: relate our patterns to classical Gang of Four patterns

\section{Identified design patterns}

In our exploration we found that patterns which tend to emerge during programming with types can be broadly divided into two categories: (1) compensation for language limitations (2) validation of program structure at compile-time (CT).

\subsection{Compensation for language limitations}

Rust is in continuous development. 
Some features have been work-in-progress for over years and are still nowhere near completion. 
Others have seen minimal-viable-product releases, and some are merely the subject of wishful thinking and speculation. 
Features we found useful in type-based design fall into all of these categories. 
Most of them can be emulated with varying levels of complexity and user experience degradation.

Stemming from often contrived usage of type system and different language features
resulting error messages are very verbose and difficult to interpret.

\subsubsection{Variadic Generics}

\paragraph{Problem}

It is common practice among programming language developers to support variadic function arguments - functions which can accept arbitrarily many arguments.
This capability is a major syntactic convenience and serves as a tool for more complex abstractions.

It is substantially less common to support variadic type parameters in generic types; in fact, Rust has no such language feature.
One highly desirable use case for such variadic generics was identified: non homogenous collections. 

\paragraph{Solution}

Rust has an excellent support for recursive types thanks to the \texttt{impl} syntax, and since lists can be defined recursively we derived a variadic generics emulation scheme from that.
We used type level recursion on binary tuples (recursive step) and unit type as \texttt{Nil}. We call such recursive type list a \textbf{HList}.
HLists can be wound to the left: first tuple component contains n - 1 elements and second the n'th type or to the right in reverse order.
These two schemes are equivalent in terms of functionality, but differ in terms of potential user experience.
In our use case appending new types to the end of a HList was by far the most common use case, and as such we almost exclusively use left wound HLists (LHLists).

Implementation of functionality for HLists needs to mirror their abstract and recursive nature. This can be achieved using two \texttt{impl}s, 
one for unit in the base case and another recursive for a the binary tuple for recursive step.

These homogenous collections have been implemented as an independent module called \texttt{hlist} which can be found in the root of our crate.
 
\paragraph{Use case}

In \texttt{gpu-bulwark} HLists are used every time variable-length user configuration is required, most notably to represent shader inputs, outputs, used uniforms or external resources like textures.
Almost always we create a facade marker trait which joins together predefined pieces of functionality from \texttt{hlist} module
and adds specialized requirements for HList member types in order to prohibit creation of invalid type list.

\subsection{Const generics in const expressions}

\paragraph{Problem}

Const generics fall into the category of partially implemented features. Const generic types depend on a value of limited subset of types, most notably numeric types, bool and unit.
This feature, being in its early stages, has a significant limitation: const parameters must be literals or expressions using only literals. 
Const parameters cannot be used in any type level const expressions, they have to be used directly. 
As a result, we cannot perform arbitrary compile-time (CT) computations on these parameters for purposes of verification.

\paragraph{Solution}

However, there is one exception to that limitation: associated constants. Associated constants can have their values computed using CT \texttt{const fn}s and themselves be used in such computations as parameters.
These functions can panic with static error message (no formatting) and may cause compilation errors based on programable logic.
As a consequence, different limitation was imposed: associated constants cannot be used as const parameters in types, they can only be used as values in code.

\paragraph{Use case}

Due to the lack of negative reasoning, as of yet, in Rust compiler we cannot express type inequality.
The only viable solution would be to a blanket impl stating that two types are different if they are not the same type; since such a blanket would apply to user defined types as well.

CT validation that types are all different is required to assert that glsl variable layout locations do not overlap.
In certain scenarios when layout components are used this overlap may be valid; we ignored it in this work because it can be easily taken into account in future releases.

We use associated constants and conditionally panicking \texttt{const} function to check that location ranges do not overlap.

\subsection{Effect system}

\paragraph{Problem}

First class effect system is a non-existent feature that would be of immense value in the context of an OpenGL wrapper implementation.
Ability to type check function invocation context in OpenGL would be especially useful as we could encode presence of appropriate object binding using an effect.

\paragraph{Solution}

We instead were forced to opt for more error prone and verbose approach. 
Objects like textures or buffers can produce binder objects which in their constructor bind, and in their destructors unbind, object appropriate binding point.
This lets us control binding using lexical scope but does not in any way prevent overriding of the binding.

\paragraph{Usae Case}

As already mentioned effect system would greatly improve the handling of context bindings in terms of statically verifiable correctness, as well as, user and developer experience.

\subsection{Application of existing features}

\subsection{Markers}

\paragraph{Problem}

Enumeration types are a core component of almost all currently used programming languages. In recent years many languages even gained ability to store dynamic data in enum variants.
Such enums provide simple mechanism for statically typed polymorphism with dynamic variants. 
However sometimes this dynamic-ness of enums is a hurdle causing constant match or switch statements to crop you all over the code base, producing clutter and boilerplate.
Sometime one simply wishes to encode static configuration based on a closed set of possible values.

\paragraph{Solution}

Markers are traits and types which don't provide any runtime behavior, but rather exist for purposes of conveying information and constrains on a type level.
Marker traits provide no useful functionality but rather serve to impose relations and logical division on types.

Marker types don't hold any data and as such don't exist at runtime (they occupy zero bytes and are formally called Zero Sized Types - ZST).
It is even possible to marker types to have type, lifetime and const parameters by using special compiler intrinsic datatype - \texttt{PhantomData} - which binds parameters but does not hold any value.

Marker traits along with marker types can be used as:
\begin{itemize}
    \item compile-time enums -- by limiting access to a marker using item visibility qualifiers we strictly control what types implement given functionality.
    \item marker trait based relations -- we can express relations between types and make unsound parameter combinations a compile-time error.
    \item typing external resources -- by using \texttt{PhantomData} we can attach type information to otherwise untyped parts of API.
\end{itemize}

\paragraph{Use Case}

We make heavy use of markers to implement entirety of glsl module which consists almost elusively of ZSTs for purposes of modelling shader \texttt{in}, \texttt{out} and \texttt{uniform} variables.
Types representing these variables aggregated into hlists are specified by the user with help of GLSL DSL implemented using lightweight declarative macros.

Marker traits in miscellaneous \texttt{\_::valid} modules define relations between valid combinations of data types. Buffer in raw OpenGL, due to C's lack of generics, has its buffer populated using \texttt{*void} 
and the documentation enumerates valid types. To make things worse validity of data types changes depending on what's the buffer's target.
It is illegal for index buffer to contain anything other than unsigned integers, pixel buffers can contain almost everything and vertex buffers, yet again, can contain only specific combinations of data.
By associating a phantom type with a Buffer and using marker trait based validation relations on uploaded data we solve both of these issues.

This methodology can be extended to form \textbf{many modes} pattern, in which one uses marker types that implement trait 
containing generic associated types (GAT) to control behavior in more complex fashion than using non-generic associated types.

\paragraph{many modes}

We use many modes in \texttt{Variable<S, L, T, Store>} to abstract over kind of storage used for variable's type member - \texttt{Phantom} or \texttt{Inline}.
\texttt{Phantom} uses \texttt{PhantomData} as its associated type and effectively discards value and \texttt{Inline} keeps it as is.

\subsection{Subtyping}

\paragraph{Problem}

Subtyping or inheritance is a very common concept in object oriented programming. 
In these languages one can create a type, and inherit from it to produce more specialized subtype which can be used in all places the parent can.
This is 



\

Using generic type and automatic dereferencing via \texttt{Deref} we can emulate the relation of subtyping


\subsection{Type State}

Type state is very powerful pattern that takes advantage of how rust understands generic types and allows for tracking runtime capabilities at compile-time.
For the duration of this subsection it is worth to think about generic types as of type constructors which can be partially applied to create another constructor or fully applied to produce a type.

Recall from chapter 1 that Rust determines if \texttt{impl}s are coherent, what it means is that each associated item resolves uniquely.
Generic type with one of it's parameters supplied can have an inherent \texttt{impl} for 

\section{OpenGL wrapper}
  
